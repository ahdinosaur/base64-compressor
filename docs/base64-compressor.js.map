{
  "version": 3,
  "sources": ["../src/index.ts", "../src/base64url.ts", "../src/compress.ts"],
  "sourcesContent": ["import {\n  encodeBase64Url,\n  decodeBase64Url\n} from './base64url.js'\nimport {\n  compress,\n  decompressAsString,\n  decompressAsArrayBuffer\n} from './compress.js'\n\nexport async function encode(value: any): Promise<string> {\n  return encodeBase64Url(\n    await compress(JSON.stringify(value))\n  )\n}\n\nexport async function decode(text: string): Promise<any> {\n  return JSON.parse(await decompressAsString(\n    decodeBase64Url(text)\n  ))\n}\n\nexport async function encodeBinary(value: ArrayBuffer): Promise<string> {\n  return encodeBase64Url(\n    await compress(value)\n  )\n}\n\nexport async function decodeBinary(text: string): Promise<ArrayBuffer> {\n  return await decompressAsArrayBuffer(\n    decodeBase64Url(text)\n  )\n}\n", "/**\n * Base64 URL: Base64 encoding with URL-safe character set\n *\n * - Replace `+` with `-`\n * - Replace `/` with `_`\n * - Remove `=` padding\n */\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\n\nexport function encodeBase64Url(arraybuffer: ArrayBuffer): string {\n  const bytes = new Uint8Array(arraybuffer)\n\n  let i\n  const len = bytes.length\n  let base64 = ''\n\n  for (i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2]\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)]\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)]\n    base64 += chars[bytes[i + 2] & 63]\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1)\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2)\n  }\n\n  return base64\n}\n\nlet lookup: Uint8Array | undefined\n\nexport function decodeBase64Url(base64: string): ArrayBuffer {\n  // Create lookup table to find the index\n  if (!lookup) {\n    lookup = new Uint8Array(256)\n    for (let i = 0; i < chars.length; i++) {\n      lookup[chars.charCodeAt(i)] = i\n    }\n  }\n\n  const len: number = base64.length\n  let bufferLength: number = (len * 3) / 4\n\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--\n    }\n  }\n\n  const arraybuffer = new ArrayBuffer(bufferLength)\n  const bytes = new Uint8Array(arraybuffer)\n\n  let encoded1: number\n  let encoded2: number\n  let encoded3: number\n  let encoded4: number\n  let p = 0\n\n  for (let i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)]\n    encoded2 = lookup[base64.charCodeAt(i + 1)]\n    encoded3 = lookup[base64.charCodeAt(i + 2)]\n    encoded4 = lookup[base64.charCodeAt(i + 3)]\n\n    bytes[p++] = (encoded1 << 2) | (encoded2 >> 4)\n    bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2)\n    bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63)\n  }\n\n  return arraybuffer\n}\n", "// Browser and server\nconst { CompressionStream, DecompressionStream, Response } = globalThis\n\ntype CompressionFormat = 'gzip' | 'deflate' | 'deflate-raw'\n\nexport async function compress(\n  data: string | ArrayBuffer,\n  compressionFormat: CompressionFormat = 'gzip',\n): Promise<ArrayBuffer> {\n  const compressor = new CompressionStream(compressionFormat)\n  const stream = new Response(data).body?.pipeThrough(compressor)\n  return await new Response(stream).arrayBuffer()\n}\n\nasync function decompressAsResponse(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = 'gzip',\n): Promise<Response> {\n  const decompressor = new DecompressionStream(compressionFormat)\n  const stream = new Response(bytes).body?.pipeThrough(decompressor)\n  return await new Response(stream)\n}\n\nexport async function decompressAsArrayBuffer(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = 'gzip',\n): Promise<ArrayBuffer> {\n  return (await decompressAsResponse(bytes, compressionFormat)).arrayBuffer()\n}\n\nexport async function decompressAsString(\n  bytes: ArrayBuffer,\n  compressionFormat: CompressionFormat = 'gzip',\n): Promise<string> {\n  return (await decompressAsResponse(bytes, compressionFormat)).text()\n}\n\nexport { decompressAsArrayBuffer as decompress }\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "decode", "decodeBinary", "encode", "encodeBinary", "chars", "encodeBase64Url", "arraybuffer", "bytes", "i", "len", "base64", "lookup", "decodeBase64Url", "bufferLength", "encoded1", "encoded2", "encoded3", "encoded4", "CompressionStream", "DecompressionStream", "Response", "compress", "data", "compressionFormat", "compressor", "stream", "decompressAsResponse", "bytes", "decompressor", "decompressAsArrayBuffer", "decompressAsString", "encode", "value", "encodeBase64Url", "compress", "decode", "text", "decompressAsString", "decodeBase64Url", "encodeBinary", "decodeBinary", "decompressAsArrayBuffer"]
}
